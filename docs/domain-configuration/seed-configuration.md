---
layout: page
title: Seed Configuration
nav_order: 70
parent: Domain Configuration
---

# Seed Configuration

When developing, testing or depploying an API having reliable test or initial data comes very handy. Therefore ActiveQL supports the generation of seed data with some nice convenient features. 

```typescript
export type SeedType = {
  [attribute:string]:SeedAttributeType
}

export type SeedAttributeType = string | number | boolean | (( evalContext:SeedEvalContextType) => any) | {
  eval?:string
  sample?:(string|number|boolean)[]|string
  faker?:string
  hash?:string
  rfs?:string
  size?:number
  random?:number
  min?:number
  max?:number
  share?:number
}

export type SeedEvalContextType = {
  idsMap?:any
  seed:any
  runtime:Runtime
}
```

## Static values

You can simply state values for every attribute you want to provide with seed values. 

```yaml 
enum:
  Gender:
    - male
    - female
    - diverse

entity: 
  Driver:
    attributes:
      firstname: String!
      lastname: String!
      gender: Gender
    seeds:
      - firstname: Thomas
        lastname: Thompson
        gender: male
      - firstname: Max
        lastname: Meyer
      - firstname: Lisa
        lastname: Simpson
        gender: female
```

## Dynamic values

Adding a whole lot data as yaml values can cumbersume. You can let ActiveQL take care of generating dynamic data, using random or "faked" data. 

Just specify the number of items you want to generate and instructions about how to get random values for the attributes. In the following example `10` items would be generated. 

```yaml 
enum:
  Gender:
    - male
    - female
    - diverse

entity:
  Driver:
    attributes:
      firstname: String!
      lastname: String!
      gender: Gender
    seeds:
      10:
        firstname:
          faker: name.firstName
        lastname:
          faker: name.lastName
        gender:
          share: 0.3
          sample: Gender
```

These are the possibilities for generated seed data:

| | |
| - | - |
| value | every generated item will get this value 
| [random](#random) | random numbers 
| [faker](#faker) | specifies a value generated by the [FakerJS Library](https://github.com/marak/faker.js) 
| [sample](#sample) | random sample from an array, enum or other entity data 
| [hash](#hash) | hash for a string, can be used to avoid plain passwords in the datastore 
| [rfs](#rfs) | a simple random formatted string, to generate values that should a certain pattern 
| [eval](#eval) | a string that is evaluated as expression 
| [Function](#Function) | callback function that is called to generate the value 

### Share

Any of the possible ways to generate data can have `share` property (`0..1`) to indicate only some of the generated data should have a value at all. This is to mimic real live data, for which you usually you would not have for all (non-null) attributes actual values.

```yaml
gender: 
  share: 0.3
  sample: Gender
```

In this example ca. 30% of the generated data would have a gender value, ca. 70% not. Keep in mind this is random data so `share` will not be exact.

### Random

Random values will only be generated for attributes of the type `Float` or `Int`. 

| | |
|-|-|
random | if random is a number it is the upper border (incl.) or maximum for the generated number 
random.min | the lower border (incl.) of the generated random number; default: `0` 
random.max | the upper border (incl.) of the generated random number; default: `100000` for `Int` and `1` for `Float`

***for Int attribute***

```yaml
example1:           # any int number 0 ... 10 
  random: 10    

example2:           # any int number 100 ... 300
  random: 
    min: 100
    max: 300        

example3:           # any int number 100 ... 100000
  random: 
    min: 100    

example4:           # any int number 0 ... 200 
  random: 
    max: 200    
```

***for Float attribute***

```yaml
example1:           # any float number 0 ... 1
  random: 1  

example2:           # any float number 1 ... 3
  random: 
    min: 1
    max: 3        

example3:           # unalllowed since min > max (default 1) 
  random: 
    min: 2    

example4:           # any float number 0 ... 2
  random: 
    max: 2    
```

### Faker 

You can use any expression from the wonderful [FakerJS Library](https://github.com/marak/faker.js) to generate seed data. Simply state the expression seperated by a dot - without function parantheses. If you need to call the faker methods with parameters you can use the library in an [eval](#eval) expression. 

```yaml
entity:
  Car: 
    attributes: 
      brand: String!
      color: String
    seeds:
      10: 
        brand: 
          faker: vehicle.manufacturer
        color:
          faker: vehicle.color 
  Driver:
    attribute: 
      firstname: String!
      lastname: String!
    seeds:
      10:
        firstname:
          faker: name.firstName
        lastname:
          faker: name.lastName
```

### Sample

You can specify the following sources to get a sample for the seed data:

***Array***

Simply write an array of values in the samples property. Exactly one item will be picked from it. If you also want seed items with no color, you could specify a `share` property.

```yaml
color: 
  sample: 
    - red
    - green
    - blue
    - black
```

***Enum***

You can specify any `enum` from the domain configuration.

```yaml
enum:
  Color:
    - red
    - green
    - blue
    - black

entity:
  Car:
    attributes:
      color: Color
    seeds:
      20:
        color:
          sample: Color
```

#### ***List sample values***

If you have a `list` attribute field, you can specify a `size` of how many items from the array should be part of the sample (default: `1`).

```yaml
entity:
  Car:
    attributes: 
      color: [String]
    seeds:
      color: 
        sample: 
          - red
          - green
          - blue
          - black
        size: 2               # will always pick to colors from the array
```

If you want a random number of items to be picked you can specify a `random` propery: 

```yaml
color: 
  sample: 
    - red
    - green
    - blue
    - black
  random: 3     # will pick 0 ... 3 items from the array
```

If you have `size` and `random` property they will be added. 

```yaml
color: 
  sample: 
    - red
    - green
    - blue
    - black
  size: 1
  random: 2     # will pick 1 ... 3 items from the array
```

### Hash

If you want to seed a hashed password field e.g. used for the `JWTLogin` included in the starter application you can use this method.

```yaml
User:
  seeds:
    - username: User1
      roles: guest
      password:
        hash: passwordForUser1
```

The value for `password` in the DataStore will be someting like `$2a$10$lulvGsUIP7bZ3TlCw02Bw...`

The `JWTLoging` (or any oher implementation) can check if the provided password was correct like so 

```typescript
const login = async (runtime:Runtime, username:string, password:string) => {
  const user = await findUser( runtime, username );
  if( user && await bcrypt.compare( password, user.password ) ) return generateToken( user );
}
```

<a id="rfs"></a>
### Random Format String (RFS)

Sometimes you need random values that follow a certain pattern or format. While you can always use an [eval](#eval) expression or add a function callback to provide for that there is an easy way to do this in a more expressive way using the `RandomFormatString` or `rfs` syntax. 

You build a formatted string by appending values, using the `append` method.

```typescript
append( values:string|string[], count?:number, randMax?:number, share?:number ):RandomFormatString 
```

| Parameter | Type | default | |
|-|-|-|-|
| values | string \| string[] | | the value to append, if value is an array, count and randMax decide what to append
| count | number | 1 | how many items from the values array should at least be appended to the result
| randMax | number | 1 | random number of items from the values (count ... randMax) array should be appended to the result
| share | number | 1 | probability (0...1) of appending the values(s) at all


To add just random characters you can use the following constants from the class `RandomFormatString``

| | |
|-|-|
| alphaLower    | `['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o', ... ]`
| alphaUpper    | `['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O', ... ];`
| numeric       | `['0','1','2','3','4','5','7','8','9']`
| specialChars  | `['^','!','§','$','%','&','/','(',')','?',',','.','-','_',':','<','>']`


As shortcuts to add a number of alpha, numeric or alphanumeric characters you can use the following methods (with the same method signature - except the values - as the `append` method.)

| | | 
|-|-|
| alphaLower  | lower alpha characters  | 
| alphaUpper  | upper alpha characters | 
| alpha       | alpha characters (lower, upper mixed) | 
| numeric     | numeric characters | 
| specialChars| special characters | 

So `alphaLower(10).numeric( 2, 3, .7 ).specialChars(1, 0, 1)` which you can read as 

* 10 random lower alpha characters
* followed by (with 70% probaility) 2 to 3 random numeric characters
* followed by 0 or 1 special characters

is just a shortcut for 

```typescript
const result = new RandomFormatString().
  append( RandomFormatString.alphaLower, 10).
  appeand( RandomFormatString.numeric 2, 3, .7 ).
  apppend( RandomFormatString.specialChars, 1, 0, 1);
```

The following example would give a random string like `HH-TR 2021` (which is the german licence plate format).

```yaml
licence:
  rfs: alphaUpper(1, 3).append(['-', ' ']).alphaUpper( 2, 3 ).append(' ').numeric( 3, 4 )
```

### eval

For more complex calculations you can provide an expression that is evaluated using `eval`. Beside the standard Javascript objects you can use the following objects inside the expression 

|||
|-|-|
| faker | the [FakerJS](https://github.com/marak/faker.js) Library object of the current locale
| ld | the amazing [Lodash](https://lodash.com) library (alas `_` does not work, therefore `ld.random()` instead of `_.random()`
| seed | the current seed configuration
| idsMap | the map with all ids of the generated seed items - for building references <br> in the format `{entityName: {seedItemName: seedId }}`
| rfs | a [RandomFormatString](#rfs) object
| RandomFormatString | the RandomFormatString class

### Function 

You can also provide a callback function to generate the seed value. 

```typescript
(evalContext:SeedEvalContextType) => any|Promise<any>
export type SeedEvalContextType = { idsMap?:any, seed:any, runtime:Runtime }
```

```typescript
const lastNameGenerator = () => _.sample( ['Meyer','Smith','Johnson','Hoffman'] );

export const domainConfiguration:DomainConfiguration = {
  entity: {
    Driver: {
      seeds: [{
        lastname: (() => lastNameGenerator()),
        firstname: { faker: 'name.firstName' },
      }]
    }
  }
}
```
